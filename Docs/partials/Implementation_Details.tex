\section{Implementation Details}

\subsection{Server-side Implementation}
\label{srv-side-imp}
The server which we built for the project was built using NodeJS, using custom helper classes, modules from npm and built in NodeJS modules. Three helper classes were programmed for the server; binaryHelper.js, hashHelper.js and dbHelper.js with each dealing with the type of functionality their names suggest. binaryHelper.js was written to deal with all of the binary requirements of the routes, hashHelper.js for dealing with calculating the hash and converting a hash back to its original data and dbHelper.js for dealing with all of database requests. These files were created to abstract away some of the functionality and make the code within the route files easier to read, as well as make adding new functionality to the program cleaner and easier. The npm and NodeJS modules which we used in the server are express.js and the http module.\\
 
The design of the server was to have HTTP routes available as an API which provided the functionality of the algorithm outlined in the paper. Other helper routes were added as well to allow us to more easily interact with the database and server as it is on a standalone Raspberry Pi and manually adding or changing data within the Raspberry Pi’s database can be an involved process. In total five routes were exposed in the API we developed for our project and the functionality of each is listed below.
 
\subsubsection{/auth/tag}

Input : \{ \verb|tReq: Integer, alpha: Integer| \}\\
Output : \{ \verb|tRes: Integer, beta: Integer| \}\\
 
The purpose of this route is for the verification of a tag through the supplied integers \verb|tReq| and \verb|alpha|. \verb|tReq| is a hashed integer containing the information of the \verb|tagID| as well as the\verb| rs_i| (random value stored on the tag). \verb|Alpha| is the integer result of performing the operation \verb|rs_i| XOR \verb|r_t| (a random number generated by the client).\\
 
In order to authenticate the tag as valid, \verb|tReq| is first run through a function to retrieve the unhashed integer representing the data. This integer is then converted into a binary string of length 14 with the left most 8 bits representing the \verb|tagID| in binary and the remaining 6 bits representing the \verb|rs_i| in binary. These two binary strings are converted to their respective integer values. The server checks the database to ensure that they correspond to the value stored in the database, returning an error if either the \verb|tagID| doesn’t exist, or the \verb|rs_i| doesn’t correspond to the \verb|tagID| in the database.\\
 
Now that the tag is verified, the server generates a new random value (\verb|rs_i1|) in order to be passed back to the client to be written to the tag. \verb|r_t| is extracted from \verb|alpha| by performing \verb|rs_i| XOR \verb|alpha|. Using this extracted \verb|r_t|, \verb|tRes| is calculated using \verb|rs_i1| XOR \verb|r_t|. \verb|Beta| is calculated by appending the binary strings of \verb|rs_i1|, \verb|r_t| and \verb|rs_i| together after ensuring each binary string was 6 digits long, appending zeros to the left side if needed. This 18 digit binary string is now converted to an integer, then run through the hash function. The database now updates the random number for \verb|tagID| as \verb|rs_i1| and then returns a json object containing \verb|tRes| and \verb|beta| as a response to the request.
 
\subsubsection{/auth/client}
 
Input : \{ \verb|tReq : Integer, dReq : Integer, p : Integer| \}\\
Output : \{ \verb|tRes : Integer, dRes : Integer, alpha : Integer| \}\\
 
The purpose of this route is for the verification of authenticity of both a client device and a tag using the supplied integers \verb|tReq|, \verb|dReq| and \verb|p|. \verb|tReq| is a hashed value representing the \verb|tagID| and \verb|rs_i| (tag random value) where \verb|dReq| is a hashed value representing the \verb|clientID| and \verb|rd_i| (client random value). \verb|p| is an integer such that L/2 < \verb|p| < L where L is the maximum binary string length of a \verb|tagID| and \verb|clientID|, in our case L = 8.\\
 
In order for the server to verify that both the tag and client are valid it first runs both \verb|tReq| and \verb|dReq| through a function to read the hashed data contained within each, then both are converted to 14 digit binary strings. \verb|tagID| and \verb|clientID| binary strings are extracted from \verb|tReq| and \verb|dReq| respectively by taking the first 8 bits of those binary strings, then converted from binary to integers. \verb|rs_i| and\verb| rd_i| are also extracted from \verb|tReq| and \verb|dReq| respectively using the last 6 bits of the binary string and converting them from binary to integers. The server now uses these values to check the database to ensure that the \verb|clientID| corresponds to a valid client device, \verb|tagID| corresponds to a valid tag, the \verb|rd_i| is the stored random value for that device and that \verb|rs_i| is the same stored random value for that tag. If any of these database checks results in finding mismatched information or a tag/device that doesn’t exist, the process is stopped and an error is returned.\\
 
Now that the tag and device are both validated, new random values are generated for the tag (\verb|rs_i1|) and client device (\verb|rd_i1|). The server now has to calculate the partial \verb|tagID| (\verb|pid_t|) and partial \verb|clientID| (pid\_c). This is done by selecting the \verb|p| least significant (rightmost) bits of the binary strings of \verb|tagID| and \verb|clientID|, then converting the \verb|p| bit long strings back into integers. \verb|tRes| is calculated as \verb|pid_t| XOR \verb|rs_i1| and \verb|dRes| is calculated as pid\_c XOR \verb|rd_i1|. \verb|Alpha| is calculated in a couple of steps. The binary strings of \verb|rs_i1|, \verb|pid_t| and \verb|rs_i| are appended in that order. The resulting binary string is converted to an integer, then ran through the hash function. After all of this, the database is updated with the new random values \verb|rs_i1| and \verb|rd_i1| and then a JSON object containing \verb|tRes|, \verb|dRes| and \verb|alpha| is sent as a response to the request.
 
\subsubsection{/initialize-nfc/client}
 
Input : none\\
Output : \{ \verb|cid : Integer, crand : Integer| \}\\
 
The purpose of this route was mostly for testing purposes. It was built only to create ease of use for initializing clients in the database and returning a JSON representation to be assigned to the program running on the client device. In a real world implementation this route would be protected or exist only as a script that administrators had access to.
 
\subsubsection{/initialize-nfc/tag}
 
Input : none\\
Output : \{ \verb|tid : Integer, trand : Integer| \}\\
 
The purpose of this route was mostly for testing purposes. It was built only to create ease of use for initializing tags in the database and returning a JSON representation to be written to the tag being initialized. In a real world implementation this route would be protected or exist only as a script that administrators had access to.
 
\subsubsection{/view-entries}
 
\begin{tabbing}
    Input : none\\
    Output : \{ \=\verb|clients : [ { cid : Integer, crand : Integer } ], |\\
            \>\verb|tags : [ { tid : Integer, trand : Integer } ]| \}\\
\end{tabbing}
 
The purpose of this route was mostly for testing purposes. This is a helper route which allows us to easily see what is going on in the database in a returned JSON object containing all clients and tags in the database. This would be insecure in a real world implementation and would not exist publicly.

\subsection{Client-side Implementation}
\label{client-side-imp}
The client was developed as a command based implementation. This implementation was decided on to be able to easily update or add features as necessary. Using the commands we are able to do a wide range of tests to confirm that the algorithm is working as expected as well as be able to test for potential attacks. The client is able to create new clients and tags, is able to authenticate an individual tag as well as a tag and client together. We also included functionality to be able perform malicious actions such as corrupt client or tag information for testing purposes. Functionality to display general information such as all tag and client entries in the database and read tag information was also included in the client.\\

A number of helper functions were written to be able to complete the client implementation. This includes functions to make a binary string a specific length and our custom hash function to complete tasks for the authentication algorithms. We also made functions to make HTTP GET and POST requests to our server that can send and receive data. Finally, two functions to access the NFC card reader were used, one to read and one to write. These functions were developed with the NFCpy library, the NFC card reader is accessed over the Raspberry Pi’s serial port which uses Teletype (TTY) protocol to send and receive information. NFCpy is able to connect to the serial port and communicate with the PN532 NFC/RFID controller as the library has support for this device. Then we can sense the tag that is placed on the device and able to read and write to the tag until the connection is closed.\\

Storing information on the NFC tag itself was a design challenge. We needed something that could be quickly read from and be computer understandable. In the end, we decided to use the text data type and write JSON formatted text to the tag. This allowed us to read in the first text record on the tag and translate it into JSON without having to write additional helper functions since Python works well with JSON. The information stored on the tag is the tag ID and the tag random number. The JSON stored on the tag is { \verb|“tid”: #, “trand”, #| }.\\

\subsubsection{Create New Client}
Utilizing the /initalize-nfc/client server function, this command will create then save a new client authentication to use in the future. 
\subsubsection{Add a New Tag}
This function utilizes /initialize-nfc/tag method on the server. This command will create a new tag on the server then write the information to the tag in JSON format. The resulting data stored on the NFC tag is a text data type with {\verb|“tid”: #, “trand”: #|}. Saving text that’s formatted as JSON allowed for us to quickly retrieve all of the data stored on the tag and could be updated to quickly include new data in the future. 
\subsubsection{Authenticate Tag \& Client}
Utilizing the /auth/client server method, this reads the tag information then performs the binary functions to generate the desired information for the server. After receiving the data from the server, we decrypt it and update both the client and tag random numbers for future usage on the server. 
\subsubsection{Authenticate Tag Only}
Using the /auth/tag server method, we first read the tag’s data. Then the client performs the binary functions to generate the desired information for the server. After receiving the results from the server, the client performs the calculations to get the tag’s new rand number and writes that information to the tag. 
\subsubsection{View All Entries (Client \& Tag)}
This command uses the /view-entries server method that returns the results of the database. This will display all of the clients and tags data. 
\subsubsection{Read Tag Data Only}
This command displays the information on the tag by reading the first text record on the tag. We only ever use one data record on the tag. 
\subsubsection{BAD: Corrupt Tag}
This command will write to the tag data that contains the wrong tag random number so that the tag cannot be authenticated. 
\subsubsection{BAD: Corrupt Client}
This command will change the current client’s random number so that the client cannot be authenticated. 
\subsubsection{Exit program}
Safely close the program by closing the connection to the NFC Reader. 


\subsection{Database Design}
\label{db-design}
The database was designed with the standard CRUD operations (create, read, update, delete) in mind. These operations are necessary for initializing, updating and removing the data for NFC tag and client device data. The database consists of two entity sets and one relationship set. There is an entity set for storing client device IDs and shared secrets named clients and the other entity set stores IDs and shared secrets of all tag entities. In each of these sets, the IDs for tags and client devices are used as the primary key as no two tags nor any two client devices should have the same ID. These IDs will never change for any existing tags or client devices, however the update operation is used to update a tag and clients shared secret as needed by the authentication protocol.\\

The relationship set, denoted as scanned, stores tag-client ID pairs which are used in the authentication process. This set has two main cases where data is retrieved. The first case is to identify client devices which have permission to overwrite the data of a scanned tag. The second case where tag-client ID pairs are needed is when identifying what tags a client device is able to scan. The former is used within the authentication process since when a client device scans a tag, the ID of both the tag and the client device is sent to the server. The latter allows the administrator of the system to retrieve all tags a client device is able to overwrite. As an added feature both tag IDs and client device IDs stored in this table are foreign keys meaning that these objects must exist within either entity set table for an ID pair to be formed and inserted into this table. This prevents unauthorized tag-client ID pairs from being formed. In addition to this feature, the database also makes use of triggers whenever a tag or client device is removed from their respective table. These triggers will remove entries in the scanned table which correspond with the deleted tag or client device object.\\

\noindent The database interacts with the server as follows:
\begin{enumerate}
    \item Once the received data is processed by the server, each entity set is queried for its respective object.
    \begin{enumerate}
        \item If the object is found in its respective table then the data from the table row is used to create an instance of the object using the object’s model.
        \item If the object is not found, then the protocol is aborted.
    \end{enumerate}
    \item Once both tag and client device objects have been returned, their ID pair is queried from the scanned relationship set
    \begin{enumerate}
        \item If the ID pair is found, the ID pair is returned and allows the protocol to continue.
        \item Otherwise, the protocol is aborted.
    \end{enumerate}
    \item The database is given update queries to update the scanned tag’s shared secret and the client device’s shared secret as described in section \ref{srv-side-imp}
\end{enumerate}